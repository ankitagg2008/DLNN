{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "0663e7da",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import cv2\n",
    "from PIL import Image\n",
    "import os\n",
    "from skimage import color\n",
    "from skimage.feature import hog\n",
    "from sklearn import svm\n",
    "from sklearn.neighbors import KNeighborsClassifier # using 1NN\n",
    "from sklearn.svm import SVC\n",
    "from sklearn.metrics import accuracy_score\n",
    "from tqdm import tqdm \n",
    "from torchvision.utils import make_grid\n",
    "from torchvision.utils import save_image"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f927e50a",
   "metadata": {},
   "source": [
    "# 1. Download the [cow teat datasets](https://github.com/YoushanZhang/SCTL) (10 points) resize image to (224, 224)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ab0c625d",
   "metadata": {},
   "source": [
    "### (1). Create a train data loader that returns image arrays and labels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "18b0b565",
   "metadata": {},
   "outputs": [],
   "source": [
    "def train_data_loader(train_dirs):\n",
    "    # Initialize empty lists for to store image arrays and labels\n",
    "    image_arrays = []\n",
    "    image_labels = []\n",
    "   \n",
    "    # loop to navitage all directories and read information from all the image files\n",
    "    for label, directory in enumerate(sorted(os.listdir(train_dirs))):\n",
    "        path = os.path.join(train_dirs, directory)\n",
    "\n",
    "        # check if it's a directory\n",
    "        if not os.path.isdir(path):\n",
    "            continue\n",
    "\n",
    "        # Iterate over image files in the directory\n",
    "        for img_file in os.listdir(path):\n",
    "            img_path = os.path.join(path, img_file)\n",
    "\n",
    "            # resize and store images\n",
    "            img = cv2.resize(plt.imread(img_path).copy(), (224, 224))\n",
    "            image_labels.append(label)\n",
    "            image_arrays.append(img)\n",
    "            \n",
    "    return image_arrays, image_labels"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "95c75bdb",
   "metadata": {},
   "source": [
    "### (2). Create a test data loader that returns image arrays and file names"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "541e9cb4",
   "metadata": {},
   "outputs": [],
   "source": [
    "def test_data_loader(data_dir):\n",
    "    # Get a list of image files in the test data directory\n",
    "    image_files = [f for f in os.listdir(data_dir) if f.endswith(\".jpg\")]\n",
    "    \n",
    "    # Initialize lists for data and file names\n",
    "    image_arrays = []\n",
    "    image_names = []\n",
    "    \n",
    "    # Iterate over the image files\n",
    "    for file in image_files:\n",
    "        # Get the full path of the image\n",
    "        path = os.path.join(data_dir, file)\n",
    "        \n",
    "        # Read and preprocess the image\n",
    "        img = cv2.resize(plt.imread(path).copy(), (224, 224))\n",
    "        #img = img.astype(np.float32) / 255.0\n",
    "        \n",
    "        # Append the preprocessed image and file name to the lists\n",
    "        image_arrays.append(img)\n",
    "        image_names.append(file)\n",
    "    \n",
    "    # Convert lists to NumPy arrays and return\n",
    "    return image_arrays, image_names\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bad569b2",
   "metadata": {},
   "source": [
    "### (3). Print image arrays, labels and file names dimensions "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9e09431a",
   "metadata": {},
   "source": [
    "### Training Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "c273b98a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Training Dataset Array: (1149, 224, 224, 3)\n",
      "Training Label Shape: (1149,)\n"
     ]
    }
   ],
   "source": [
    "train_loader = r'C:\\AKA\\Backup Dell Laptop\\D Drive\\YU\\Semester 2\\Neural Network\\DLNN\\Assignment_Week5\\Homework Week5\\Homework Week5\\Training'\n",
    "training_array, training_labels = train_data_loader(train_loader)\n",
    "training_array, training_labels = np.array(training_array), np.array(training_labels)\n",
    "\n",
    "print(\"Training Dataset Array:\",training_array.shape )\n",
    "print(\"Training Label Shape:\",training_labels.shape )"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "29f15e42",
   "metadata": {},
   "source": [
    "**Observation:**\n",
    "   - The training dataset contains total 1149 images of size 224, 224 and has 3 channels."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e77b0d89",
   "metadata": {},
   "source": [
    "### Test Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "a6530b3b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Test Dataset Array: (380, 224, 224, 3)\n",
      "Test File Names Extracted: (380,)\n"
     ]
    }
   ],
   "source": [
    "# Example usage\n",
    "test_loader=r'C:\\AKA\\Backup Dell Laptop\\D Drive\\YU\\Semester 2\\Neural Network\\DLNN\\Assignment_Week5\\Homework Week5\\Homework Week5\\Test_Data'\n",
    "test_array, test_file_name = test_data_loader(test_loader)\n",
    "test_array, test_file_name = np.array(test_array), np.array(test_file_name)\n",
    "\n",
    "print(\"Test Dataset Array:\",test_array.shape )\n",
    "print(\"Test File Names Extracted:\",test_file_name.shape )\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f6afa108",
   "metadata": {},
   "source": [
    "**Observation:**\n",
    "   - The test dataset contains total 380 images of size 224, 224 and has 3 channels."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "79c5ec7c",
   "metadata": {},
   "source": [
    "# 2. Extract features of training and test images using HOG (20 points)\n",
    "Please print the size of extracted features, e.g., training features: 1149 * d, test features: 380 *d"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "cd8f13f9",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Training HOG features: 1149 * 11664\n"
     ]
    }
   ],
   "source": [
    "# Initialize lists to store features and labels\n",
    "train_hog_features = []\n",
    "train_hog_labels = []\n",
    "\n",
    "# Extract features for training images\n",
    "for i, img in enumerate(training_array):\n",
    "    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n",
    "  \n",
    "    # Compute HOG descriptors for each grayscale image\n",
    "    features = hog(img_gray, pixels_per_cell=(16, 16), transform_sqrt=False)\n",
    "    train_hog_features.append(features)\n",
    "    train_hog_labels.append(training_labels[i])\n",
    "    \n",
    "# Convert feature lists to numpy arrays\n",
    "train_hog_features = np.array(train_hog_features)\n",
    "train_hog_labels = np.array(train_hog_labels)\n",
    "\n",
    "# Print the size of extracted features\n",
    "print(f\"Training HOG features: {train_hog_features.shape[0]} * {train_hog_features.shape[1]}\")   "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "eacabc35",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Test HOG features: 380 * 11664\n"
     ]
    }
   ],
   "source": [
    "# Initialize lists to store features and labels\n",
    "test_hog_features = []\n",
    "test_hog_labels = []\n",
    "\n",
    "# Extract features for test images\n",
    "for i, img in enumerate(test_array):\n",
    "    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n",
    "    \n",
    "    # Compute HOG descriptors for each grayscale image\n",
    "    features = hog(img_gray, pixels_per_cell=(16, 16), transform_sqrt=True)\n",
    "    \n",
    "    test_hog_features.append(features)\n",
    "    test_hog_labels.append(test_file_name[i])\n",
    "\n",
    "# Convert feature lists to numpy arrays\n",
    "test_hog_features = np.array(test_hog_features)\n",
    "test_hog_labels = np.array(test_hog_labels)\n",
    "\n",
    "# Print the size of extracted features\n",
    "print(f\"Test HOG features: {test_hog_features.shape[0]} * {test_hog_features.shape[1]}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9f5339f5",
   "metadata": {},
   "source": [
    "# 3. Extract features of training and test images using SIFT (20 points)\n",
    "Please print the size of extracted features, e.g., training features: 1149 * d, test features: 380 *d"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "3e9f0084",
   "metadata": {},
   "outputs": [],
   "source": [
    "def extract_sift_features(image):\n",
    "    sift = cv2.xfeatures2d.SIFT_create(50)\n",
    "    keypoints, descriptors = sift.detectAndCompute(image,None)\n",
    "    return descriptors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "87c0348d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Training features: 1149 * 128\n"
     ]
    }
   ],
   "source": [
    "# Initialize lists to store SIFT features\n",
    "train_sift_features = []\n",
    "\n",
    "# Load the training images\n",
    "for img in training_array:\n",
    "    gray1 = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n",
    "    descriptors = extract_sift_features(gray1)\n",
    "    if descriptors is not None:\n",
    "        train_sift_features.append(descriptors.flatten()[:128])\n",
    "    else:\n",
    "        train_sift_features.append(np.array([0]*(128)).flatten())\n",
    "\n",
    "# Convert the lists to NumPy arrays\n",
    "sift_train_features = np.array(train_sift_features)\n",
    "\n",
    "# Print the size of the extracted features\n",
    "print(f\"Training features: {sift_train_features.shape[0]} * {sift_train_features.shape[1]}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "f00bf390",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Test features: 380 * 128\n"
     ]
    }
   ],
   "source": [
    "# Initialize lists to store SIFT features\n",
    "test_sift_features = []\n",
    "\n",
    "# Load the test images\n",
    "for img in test_array:\n",
    "    gray1 = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n",
    "    descriptors = extract_sift_features(gray1)\n",
    "    if descriptors is not None:\n",
    "        test_sift_features.append(descriptors.flatten()[:128])\n",
    "    else:\n",
    "        test_sift_features.append(np.array([0]*(128)).flatten())\n",
    "\n",
    "# Convert the lists to NumPy arrays\n",
    "sift_test_features = np.array(test_sift_features)\n",
    "\n",
    "# Print the size of the extracted features\n",
    "print(f\"Test features: {sift_test_features.shape[0]} * {sift_test_features.shape[1]}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "753188e2",
   "metadata": {},
   "source": [
    "# 4. Extract features of training and test images using SURF (20 points)\n",
    "Please print the size of extracted features, e.g., training features: 1149 * d, test features: 380 *d"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "1c85f786",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to extract SURF features\n",
    "def extract_surf_features(image):\n",
    "    surf = cv2.xfeatures2d.SURF_create()\n",
    "    keypoints, descriptors = surf.detectAndCompute(image, None)\n",
    "    return descriptors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "5abd5f46",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Training features: 1149 * 128\n"
     ]
    }
   ],
   "source": [
    "# Initialize lists to store SURF features\n",
    "train_surf_features = []\n",
    "\n",
    "# Load the training images\n",
    "for img in training_array:\n",
    "    descriptors = extract_surf_features(img)\n",
    "    if descriptors is not None:\n",
    "        train_surf_features.append(descriptors.flatten()[:128])\n",
    "    else:\n",
    "        train_surf_features.append(np.zeros(128, dtype=np.float32))\n",
    "\n",
    "# Convert the lists to NumPy arrays\n",
    "surf_train_features = np.array(train_surf_features, dtype=np.float32)\n",
    "\n",
    "# Print the size of the extracted features\n",
    "print(f\"Training features: {surf_train_features.shape[0]} * {surf_train_features.shape[1]}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "95d5562b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Test features: 380 * 128\n"
     ]
    }
   ],
   "source": [
    "# Initialize lists to store SURF features\n",
    "test_surf_features = []\n",
    "\n",
    "# Load the test images\n",
    "for img in test_array:\n",
    "    descriptors = extract_surf_features(img)\n",
    "    if descriptors is not None:\n",
    "        test_surf_features.append(descriptors.flatten()[:128])\n",
    "    else:\n",
    "        test_surf_features.append(np.zeros(128, dtype=np.float32))\n",
    "\n",
    "# Convert the lists to NumPy arrays\n",
    "surf_test_features = np.array(test_surf_features, dtype=np.float32)\n",
    "\n",
    "# Print the size of the extracted features\n",
    "print(f\"Test features: {surf_test_features.shape[0]} * {surf_test_features.shape[1]}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dae7fb43",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "id": "b0e3e068",
   "metadata": {},
   "source": [
    "# 5. Call SVM and kNN from scikit-learn and train the extracted HOG, SIFT and SURF features, respectively, save three CSV files of test dataset using three features (10 points)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "68704a6d",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "id": "3fd101cf",
   "metadata": {},
   "source": [
    "# 6. Report the accuracy using Cow_teat_classfication_accuracy software, please attach the results image here (20 points)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "89ea49db",
   "metadata": {},
   "source": [
    "### (1). SVM and KNN using HOG features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "8ef54b9c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Train SVM classifier on HOG features\n",
    "svmHog = svm.SVC(kernel='rbf')\n",
    "svmHog.fit(train_hog_features, train_hog_labels)\n",
    "\n",
    "# Predict using SVM classifier\n",
    "svmHog_preds = []\n",
    "for features in test_hog_features:\n",
    "    svmHog_preds.append(svmHog.predict([features]))\n",
    "\n",
    "#Convert numpy array to dataframe\n",
    "svm_preds = pd.DataFrame(svmHog_preds, test_hog_labels)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "cb8b42dd",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "HOG SVM predictions saved to CSV files\n"
     ]
    }
   ],
   "source": [
    "# Write predictions to CSV files\n",
    "svm_preds.to_csv(r\"C:\\AKA\\Backup Dell Laptop\\D Drive\\YU\\Semester 2\\Neural Network\\DLNN\\Output\\hog_test_predictions_svm.csv\")\n",
    "print(\"HOG SVM predictions saved to CSV files\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5411fbc7",
   "metadata": {},
   "source": [
    "#### SVM Accuracy with HOG Features"
   ]
  },
  {
   "attachments": {
    "acc_svm_hog-2.png": {
     "image/png": "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"
    }
   },
   "cell_type": "markdown",
   "id": "2aa24c2c",
   "metadata": {},
   "source": [
    "![acc_svm_hog-2.png](attachment:acc_svm_hog-2.png)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "2b302dcc",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Train KNN classifier on HOG features\n",
    "knnHog = KNeighborsClassifier(n_neighbors=2)\n",
    "knnHog.fit(train_hog_features, train_hog_labels)\n",
    "  \n",
    "# Predict using KNN classifier\n",
    "knnHog_preds = []\n",
    "for features in test_hog_features:\n",
    "    knnHog_preds.append(knnHog.predict([features]))\n",
    "\n",
    "#Convert numpy array to dataframe\n",
    "knn_preds = pd.DataFrame(knnHog_preds, test_hog_labels)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "0fb6a11d",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "HOG KNN predictions saved to CSV files\n"
     ]
    }
   ],
   "source": [
    "# Write predictions to CSV files\n",
    "knn_preds.to_csv(r\"C:\\AKA\\Backup Dell Laptop\\D Drive\\YU\\Semester 2\\Neural Network\\DLNN\\Output\\hog_test_predictions_knn.csv\")\n",
    "print(\"HOG KNN predictions saved to CSV files\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "be7ac2be",
   "metadata": {},
   "source": [
    "#### KNN Accuracy with HOG Features"
   ]
  },
  {
   "attachments": {
    "acc_knn_hog.png": {
     "image/png": "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"
    }
   },
   "cell_type": "markdown",
   "id": "4c790409",
   "metadata": {},
   "source": [
    "![acc_knn_hog.png](attachment:acc_knn_hog.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1163e551",
   "metadata": {},
   "source": [
    "### (2). SVM and KNN using SIFT features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "6f374e1e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Pass 1 Started at 2023-10-11 03:48:42.842531\n"
     ]
    }
   ],
   "source": [
    "import datetime\n",
    "\n",
    "# Get the current date and time\n",
    "current_time = datetime.datetime.now()\n",
    "\n",
    "# Print with the current time\n",
    "print(f'Pass 1 Started at {current_time}')\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e2fee072",
   "metadata": {},
   "source": [
    "#### SVM Accuracy with SIFT Features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f818afb9",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Test 1 Started 2023-10-11 03:48:42.842531\n",
      "Pass 1 Started at 2023-10-11 03:48:42.842531\n",
      "Pass 1 completed at 2023-10-11 03:48:42.842531\n",
      "Pass 2 Started at 2023-10-11 03:48:42.842531\n"
     ]
    }
   ],
   "source": [
    "print(f'Test 1 Started {current_time}')\n",
    "#Train SVM classifier on SIFT features\n",
    "print(f'Pass 1 Started at {current_time}')\n",
    "svmSift = svm.SVC(kernel='linear')\n",
    "print(f'Pass 1 completed at {current_time}')\n",
    "print(f'Pass 2 Started at {current_time}')\n",
    "svmSift.fit(sift_train_features,training_labels)\n",
    "print(f'Pass 2 Completed at {current_time}')\n",
    "\n",
    "# Predict using SVM classifier\n",
    "print(f'Pass 3 Started at {current_time}')\n",
    "svmSiftPred = svmSift.predict(sift_test_features)\n",
    "print(f'Pass 3 Completed at {current_time}')\n",
    "print(f'Pass 4 Started at {current_time}')\n",
    "# Convert numpy array to dataframe\n",
    "svm_preds_df = pd.DataFrame(test_file_name, svmSiftPred)\n",
    "print(f'Pass 4 Completed at {current_time}')\n",
    "print(f'Pass 5 Started at {current_time}')\n",
    "# Write predictions to CSV files\n",
    "svm_preds_df.to_csv(r\"C:\\AKA\\Backup Dell Laptop\\D Drive\\YU\\Semester 2\\Neural Network\\DLNN\\Output\\sift_test_predictions_svm_linear.csv\", index=False, header=False)\n",
    "print(\"SIFT predictions saved to CSV files\")\n",
    "print(f'Pass 5 Completed at {current_time}')\n",
    "print(f'Test 1 finished {current_time}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "71bde92e",
   "metadata": {},
   "outputs": [],
   "source": [
    "print(f'Test 2 Started {current_time}')\n",
    "#Train SVM classifier on SIFT features\n",
    "print(f'Pass 1 Started at {current_time}')\n",
    "svmSift = svm.SVC(kernel='rbf')\n",
    "print(f'Pass 1 completed at {current_time}')\n",
    "print(f'Pass 2 Started at {current_time}')\n",
    "svmSift.fit(sift_train_features,training_labels)\n",
    "print(f'Pass 2 Completed at {current_time}')\n",
    "\n",
    "# Predict using SVM classifier\n",
    "print(f'Pass 3 Started at {current_time}')\n",
    "svmSiftPred = svmSift.predict(sift_test_features)\n",
    "print(f'Pass 3 Completed at {current_time}')\n",
    "print(f'Pass 4 Started at {current_time}')\n",
    "# Convert numpy array to dataframe\n",
    "svm_preds_df = pd.DataFrame(test_file_name, svmSiftPred)\n",
    "print(f'Pass 4 Completed at {current_time}')\n",
    "print(f'Pass 5 Started at {current_time}')\n",
    "# Write predictions to CSV files\n",
    "svm_preds_df.to_csv(r\"C:\\AKA\\Backup Dell Laptop\\D Drive\\YU\\Semester 2\\Neural Network\\DLNN\\Output\\sift_test_predictions_svm_rbf.csv\", index=False, header=False)\n",
    "print(\"SIFT predictions saved to CSV files\")\n",
    "print(f'Pass 5 Completed at {current_time}')\n",
    "print(f'Test 2 finished {current_time}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9221b371",
   "metadata": {},
   "outputs": [],
   "source": [
    "print(f'Test 3 Started {current_time}')\n",
    "#Train SVM classifier on SIFT features\n",
    "print(f'Pass 1 Started at {current_time}')\n",
    "svmSift = svm.SVC((kernel='linear', C=1.0, gamma='scale', max_iter=-1))\n",
    "print(f'Pass 1 completed at {current_time}')\n",
    "print(f'Pass 2 Started at {current_time}')\n",
    "svmSift.fit(sift_train_features,training_labels)\n",
    "print(f'Pass 2 Completed at {current_time}')\n",
    "\n",
    "# Predict using SVM classifier\n",
    "print(f'Pass 3 Started at {current_time}')\n",
    "svmSiftPred = svmSift.predict(sift_test_features)\n",
    "print(f'Pass 3 Completed at {current_time}')\n",
    "print(f'Pass 4 Started at {current_time}')\n",
    "# Convert numpy array to dataframe\n",
    "svm_preds_df = pd.DataFrame(test_file_name, svmSiftPred)\n",
    "print(f'Pass 4 Completed at {current_time}')\n",
    "print(f'Pass 5 Started at {current_time}')\n",
    "# Write predictions to CSV files\n",
    "svm_preds_df.to_csv(r\"C:\\AKA\\Backup Dell Laptop\\D Drive\\YU\\Semester 2\\Neural Network\\DLNN\\Output\\sift_test_predictions_svm.csv\", index=False, header=False)\n",
    "print(\"SIFT predictions saved to CSV files\")\n",
    "print(f'Pass 5 Completed at {current_time}')\n",
    "print(f'Test 3 finished {current_time}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "da8e9e0e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# # Convert the lists to NumPy arrays\n",
    "# sift_train_features = np.array(train_sift_features, dtype=np.float32)\n",
    "# sift_test_features = np.array(test_sift_features, dtype=np.float32)\n",
    "\n",
    "# print('Pass 1 Completed')\n",
    "\n",
    "# # Ensure that your labels contain at least two classes for SVM\n",
    "# training_labels_subset = training_labels\n",
    "\n",
    "# print('Pass 2 Completed')\n",
    "\n",
    "# # Train SVM classifier on SIFT features with optimized hyperparameters\n",
    "# svmSift = svm.SVC(kernel='linear', C=1.0, gamma='scale', max_iter=-1)\n",
    "# svmSift.fit(sift_train_features, training_labels_subset)\n",
    "\n",
    "# print('Pass 3 Completed')\n",
    "\n",
    "# # # Convert the lists to NumPy arrays\n",
    "# # sift_train_features = np.array(train_sift_features[:5], dtype=np.float32)\n",
    "# # sift_test_features = np.array(test_sift_features[:5], dtype=np.float32)\n",
    "\n",
    "# # # Train SVM classifier on SIFT features with optimized hyperparameters\n",
    "# # svmSift = svm.SVC(kernel='linear', C=1.0, gamma='scale', max_iter=-1)\n",
    "# # svmSift.fit(sift_train_features[:5], training_labels[:5])\n",
    "\n",
    "# print('Pass 4 Started')\n",
    "\n",
    "# # Predict using SVM classifier with a progress bar\n",
    "# svmSiftPred = []\n",
    "# with tqdm(total=len(sift_test_features), desc=\"Predicting with SVM\") as pbar:\n",
    "#     for img in sift_test_features:\n",
    "#         prediction = svmSift.predict([img])\n",
    "#         svmSiftPred.append(prediction)\n",
    "#         pbar.update(1)\n",
    "        \n",
    "\n",
    "# print('Pass 4 Completed')\n",
    "\n",
    "# # # Predict using SVM classifier\n",
    "# # svmSiftPred = svmSift.predict(sift_test_features)\n",
    "\n",
    "# # Calculate accuracy\n",
    "# accuracy = accuracy_score(training_labels, svmSiftPred)\n",
    "# print(\"SVM Accuracy:\", accuracy)\n",
    "# print('Pass 5 Completed')\n",
    "\n",
    "# # Convert numpy array to a DataFrame\n",
    "# svm_preds_df = pd.DataFrame({'Actual': test_file_name, 'Predicted': svmSiftPred})\n",
    "# print('Pass 6 Completed')\n",
    "\n",
    "# # Write predictions to CSV files\n",
    "# svm_preds_df.to_csv(r\"C:\\AKA\\Backup Dell Laptop\\D Drive\\YU\\Semester 2\\Neural Network\\DLNN\\Output\\sift_test_predictions_svm.csv\", index=False, header=False)\n",
    "# print(\"SIFT predictions saved to CSV files\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b110bf85",
   "metadata": {},
   "source": [
    "#### KNN Accuracy with SIFT Features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3d014483",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Train KNN classifier on SIFT features\n",
    "knnSift = KNeighborsClassifier(n_neighbors=20, weights ='distance')\n",
    "knnSift.fit(sift_train_features, training_labels)\n",
    "\n",
    "# Predict using KNN classifier\n",
    "knnSiftPred = knnSift.predict(sift_test_features)\n",
    "\n",
    "# Convert numpy array to dataframe\n",
    "knn_preds_df = pd.DataFrame({'a':test_file_name, 'b':knnSiftPred})\n",
    "\n",
    "\n",
    "# Write predictions to CSV files\n",
    "knn_preds_df.to_csv(r\"C:\\AKA\\Backup Dell Laptop\\D Drive\\YU\\Semester 2\\Neural Network\\DLNN\\Output\\sift_test_predictions_knn.csv\", index=False, header=False)\n",
    "print(\"SIFT predictions saved to CSV files\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2908c75a",
   "metadata": {},
   "source": [
    "### (3). SVM and KNN using SURF features"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c4bcbf44",
   "metadata": {},
   "source": [
    "#### SVM Accuracy with Surf Features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "88a6129b",
   "metadata": {},
   "outputs": [],
   "source": [
    "train_surf_features = np.array(surf_train_features)\n",
    "test_surf_features = np.array(surf_test_features)\n",
    "\n",
    "# Train SVM classifier on SURF features\n",
    "svmSurf = svm.SVC(kernel='linear')\n",
    "svmSurf.fit(train_surf_features, training_labels)\n",
    "\n",
    "# Predict using SVM classifier\n",
    "svmSurfPred = svmSurf.predict(test_surf_features)\n",
    "\n",
    "# Convert numpy array to dataframe\n",
    "svm_preds_df = pd.DataFrame(test_file_name, svmSurfPred)\n",
    "\n",
    "# Write predictions to CSV files\n",
    "svm_preds_df.to_csv(r\"C:\\AKA\\Backup Dell Laptop\\D Drive\\YU\\Semester 2\\Neural Network\\DLNN\\Output\\surf_test_predictions_svm.csv\")\n",
    "print(\"Surf predictions saved to CSV files\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "708a13bd",
   "metadata": {},
   "source": [
    "#### KNN Accuracy with Surf Features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ff9fb829",
   "metadata": {},
   "outputs": [],
   "source": [
    "train_surf_features = np.array(surf_train_features)\n",
    "test_surf_features = np.array(surf_test_features)\n",
    "\n",
    "# Train KNN classifier on SURF features\n",
    "knnSurf = KNeighborsClassifier(n_neighbors=1)\n",
    "knnSurf.fit(train_surf_features, training_labels)\n",
    "\n",
    "# Predict using KNN classifier\n",
    "knnSurfPred = knnSurf.predict(test_surf_features)\n",
    "\n",
    "# Convert numpy array to dataframe\n",
    "knn_preds_df = pd.DataFrame(test_file_name, knnSurfPred)\n",
    "\n",
    "# Write predictions to CSV files\n",
    "knn_preds_df.to_csv(r\"C:\\AKA\\Backup Dell Laptop\\D Drive\\YU\\Semester 2\\Neural Network\\DLNN\\Output\\surf_test_predictions_knn.csv\")\n",
    "print(\"Surf predictions saved to CSV files\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cf698180",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "id": "d78b7ccd",
   "metadata": {},
   "source": [
    "https://www.analyticsvidhya.com/blog/2019/10/detailed-guide-powerful-sift-technique-image-matching-python/\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
